# -*- coding: utf-8 -*-
"""PI2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1giRsUPxwlWBMS4dfyBXEsR3CtWXGtPgg
"""

import cv2
import numpy as np

# Load the all-sky circular image
img = cv2.imread('/content/WechatIMG170.jpg')
height, width = img.shape[:2]

# Define the radius of the fisheye (from the center to the edge of the circle)
radius = width // 2  # Assuming the image is square-like, adjust for non-square images

# Create the output size for the unwrapped rectangular image
output_size = (width, height)  # You can modify this to any rectangular size you want

# Create meshgrid for the output coordinates (rectangular projection)
theta = np.linspace(0, 2 * np.pi, width)
r = np.linspace(0, radius, height)
r, theta = np.meshgrid(r, theta)

# Convert polar coordinates (r, theta) to Cartesian coordinates (x, y)
x = radius + r * np.cos(theta)
y = radius - r * np.sin(theta)

# Remap the original circular image into the rectangular output image
map_x = x.astype(np.float32)
map_y = y.astype(np.float32)
rectified_img = cv2.remap(img, map_x, map_y, interpolation=cv2.INTER_LINEAR)

# Save the unwrapped image
cv2.imwrite('/content/unwrapped.jpg', rectified_img)

import numpy as np
import cv2
import os

def stretch_fisheye(img, output_size):
    H, W = img.shape[:2]
    center_x, center_y = W // 2, H // 2
    max_radius = min(center_x, center_y)

    output_img = np.zeros((output_size[1], output_size[0], 3), dtype=img.dtype)

    for y in range(output_size[1]):
        for x in range(output_size[0]):
            norm_x = (x - output_size[0] / 2) / (output_size[0] / 2)
            norm_y = (y - output_size[1] / 2) / (output_size[1] / 2)

            r_output = np.sqrt(norm_x**2 + norm_y**2)
            theta = np.arctan2(norm_y, norm_x)

            r_input = np.arctan(r_output * np.tan(np.pi / 2)) / (np.pi / 2)
            r_input *= max_radius

            input_x = int(center_x + r_input * np.cos(theta))
            input_y = int(center_y + r_input * np.sin(theta))

            if 0 <= input_x < W and 0 <= input_y < H:
                output_img[y, x] = img[input_y, input_x]

    return output_img

# Dossier contenant les fichiers .npy
input_folder = "/content"
output_folder = "/content/"

os.makedirs(output_folder, exist_ok=True)

for file in os.listdir(input_folder):
    if file.endswith(".npy"):
        file_path = os.path.join(input_folder, file)

        # Charger les images depuis le .npy
        data = np.load(file_path)

        # Vérifier la forme des données
        if len(data.shape) == 4:  # Format (N, H, W, C)
            N, H, W, C = data.shape
        elif len(data.shape) == 3:  # Format (N, H, W) -> images en niveaux de gris
            N, H, W = data.shape
            C = 1
            data = data[..., np.newaxis]  # Ajouter une dimension pour uniformiser
        else:
            print(f"Format inconnu pour {file}, skipping...")
            continue

        for i in range(N):  # Boucle sur toutes les images du fichier .npy
            img = data[i]

            # Convertir en format OpenCV
            if C == 1:
                img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)

            # Normaliser si nécessaire
            if img.max() <= 1:
                img = (img * 255).astype(np.uint8)

            # Transformer l'image
            output_size = (512, 512)  # Modifier selon tes besoins
            stretched_img = stretch_fisheye(img, output_size)

            # Sauvegarder chaque image transformée
            output_path = os.path.join(output_folder, f"{file.replace('.npy', '')}_img{i}.jpg")
            np.save(output_path.replace('.jpg', '.npy'), stretched_img)


print("Traitement terminé !")

import numpy as np
import matplotlib.pyplot as plt

# Charger l'image depuis le fichier .npy avec allow_pickle=True
file_path = "/content/sky_images_cloudy_img53.npy"
img = np.load(file_path, allow_pickle=True)

# Vérifier si c'est une image unique ou un lot d'images
if len(img.shape) == 4:  # (N, H, W, C) -> Plusieurs images
    img = img[0]  # Afficher uniquement la première image

# Si l'image est en niveaux de gris (H, W), la convertir en RGB pour affichage
if len(img.shape) == 2:
    plt.imshow(img, cmap="gray")  # Affichage en niveaux de gris
else:
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))  # OpenCV charge en BGR, conversion en RGB

plt.axis("off")  # Cacher les axes
plt.show()

import cv2
import numpy as np

# Load the original circular image
img = cv2.imread('/content/WechatIMG170.jpg')
height, width = img.shape[:2]

# Define the size of the output square
square_size = max(height, width)

# Create normalized coordinate grid for the square
x = np.linspace(-1, 1, square_size)
y = np.linspace(-1, 1, square_size)
x, y = np.meshgrid(x, y)

# Convert grid to polar coordinates (r, theta)
r = np.sqrt(x**2 + y**2)
theta = np.arctan2(y, x)

# Normalize radius to match the input image's circle
r = np.clip(r, 0, 1) * (width / 2)

# Map polar coordinates back to the original circular image
src_x = width / 2 + r * np.cos(theta)
src_y = height / 2 + r * np.sin(theta)

# Remap the original image into the square shape
map_x = src_x.astype(np.float32)
map_y = src_y.astype(np.float32)
stretched_img = cv2.remap(img, map_x, map_y, interpolation=cv2.INTER_LINEAR)

# Save the stretched image
cv2.imwrite('/content/strech.jpg', stretched_img)

import numpy as np
import cv2

def stretch_fisheye(img, output_size):
    """
    Stretch a fisheye image into a square using radial distance transformation.

    Parameters:
    - img: Input fisheye image
    - output_size: The desired output image size (width, height).

    Returns:
    - Stretched square image
    """
    H, W = img.shape[:2]
    center_x, center_y = W // 2, H // 2
    max_radius = min(center_x, center_y)  # Max possible radius from center

    output_img = np.zeros((output_size[1], output_size[0], 3), dtype=img.dtype)

    for y in range(output_size[1]):
        for x in range(output_size[0]):
            # Normalized coordinates in the output image
            norm_x = (x - output_size[0] / 2) / (output_size[0] / 2)
            norm_y = (y - output_size[1] / 2) / (output_size[1] / 2)

            # Compute the radial distance and angle in the output image
            r_output = np.sqrt(norm_x**2 + norm_y**2)
            theta = np.arctan2(norm_y, norm_x)

            # Map this back to the original fisheye image radius (nonlinear)
            r_input = np.arctan(r_output * np.tan(np.pi / 2)) / (np.pi / 2)
            r_input *= max_radius

            # Convert back to Cartesian coordinates in the input image
            input_x = int(center_x + r_input * np.cos(theta))
            input_y = int(center_y + r_input * np.sin(theta))

            # If within bounds, copy the pixel from input to output
            if 0 <= input_x < W and 0 <= input_y < H:
                output_img[y, x] = img[input_y, input_x]

    return output_img

# Load the fisheye image
img = cv2.imread('/content/WechatIMG170.jpg')

# Stretch the fisheye into a square image
output_size = (512, 512)  # Adjust as needed
stretched_img = stretch_fisheye(img, output_size)

# Save or display the result
cv2.imwrite('/content/stretched_output.jpg', stretched_img)

cv2.waitKey(0)
cv2.destroyAllWindows()

import os
import cv2
import matplotlib.pyplot as plt
import numpy as np


def warp(img, UpSampFactor):

    #变量调整，rad半径，我默认的是图片大小的一半
    rad = 32
    rad = rad * 1.414

    width_to_height = 3

    # 设置中心点为图像中心
    cent_x = img.shape[1] / 2
    cent_y = img.shape[0] / 2

    ##加一是为了确定一个包含整个球面的正方形的边长  ceil是向上取整，UpSampFactor用于调整图像尺寸
    new_siz = np.ceil((2 * rad + 1) * UpSampFactor)

    ##生成n*n矩阵，数值是0-new_siz-1  X用于记录像素点的横坐标，便于后续处理
    X, Y = np.meshgrid(np.arange(0, new_siz), np.arange(0, new_siz))

    ###【-1，1】
    X = 2 * X / new_siz - 1
    Y = 2 * Y / new_siz - 1
    ##对单位圆做一个限制，距离大于1的点不考虑
    #dis = X**2 + Y**2

    #X[dis > 1] = 0
    #Y[dis > 1] = 0

    #mask0 = dis > 1

    X = X * (width_to_height-1)
    Y = Y * width_to_height

    rho0 = np.sqrt(X**2 + Y**2)
    phi0 = np.angle(X + 1j * Y)

    s0 = 4 * rad * rho0 * (-1 + (1 + 3 * (1 + rho0**2))**0.5) / (8 * (1 + rho0**2))

    X_res = cent_x + s0 * np.cos(phi0)
    Y_res = cent_y + s0 * np.sin(phi0)

    if len(img.shape) == 2:  # 灰度图像
        im_warp = np.zeros((X_res.shape[0], X_res.shape[1]))
        #im_warp[:, :] = (1 - mask0) * cv2.remap(img, np.float32(X_res), np.float32(Y_res), cv2.INTER_LINEAR)
        im_warp[:, :] = cv2.remap(img, np.float32(X_res), np.float32(Y_res), cv2.INTER_LINEAR)
    else:  # 彩色图像
        im_warp = np.zeros((X_res.shape[0], X_res.shape[1], img.shape[2]))
        for ch in range(img.shape[2]):
            #im_warp[:, :, ch] = (1 - mask0) * cv2.remap(img[:, :, ch], np.float32(X_res), np.float32(Y_res), cv2.INTER_CUBIC)
            im_warp[:, :, ch] =  cv2.remap(img[:, :, ch], np.float32(X_res), np.float32(Y_res), cv2.INTER_CUBIC)

    return im_warp


def unwarp(img, UpSampFactor, rad, cent_x, cent_y, width_to_height=3):
    rad = rad * 1.414

    new_siz = np.ceil((2 * rad + 1) * UpSampFactor)

    X0, Y0 = np.meshgrid(np.arange(0, 288), np.arange(0, 352))
    X0 = (X0 - cent_x)
    Y0 = (Y0 - cent_y)

    s_new = np.sqrt(X0 ** 2 + Y0 ** 2)

    phi_new = np.angle(X0 + 1j * Y0)
    mask = (s_new > 0.707 * rad)

    s_new[s_new > 0.707 * rad] = 0

    rho_new = 2 * s_new / (2 * np.sqrt(rad ** 2 - s_new ** 2) - rad)

    X_res0 = rho_new * np.cos(phi_new)
    Y_res0 = rho_new * np.sin(phi_new)

    X_res1 = (1 + X_res0 / width_to_height) * new_siz / 2;
    Y_res1 = (1 + Y_res0 / width_to_height) * new_siz / 2;

    im_UN_wrap = np.zeros((X_res0.shape[0], X_res0.shape[1], img.shape[2]))

    for ch in range(img.shape[2]):
        im_UN_wrap[:, :, ch] = (1 - mask) * cv2.remap(img[:, :, ch], np.float32(X_res1), np.float32(Y_res1),
                                                      cv2.INTER_LINEAR)

    return im_UN_wrap


# # 读取鱼眼图像#allsky_2021-07-02T0401Zdian.png
# img = cv2.imread('data/allsky_2021-09-28T1701Z.png')  # 读取灰度图像
# #img = cv2.imread('allsky_2021-07-02T0401Zdian.png')  # 读取灰度图像
# # 调用扭曲函数
# im_warp = warp(img, UpSampFactor=1)
# # 保存并显示扭曲后的灰度图像
# im_warp = np.clip(im_warp, 0, 255)  # 确保值在 0 到 255 之间
# im_warp = im_warp.astype(np.uint8)  # 转换为整型
# #im_unwarp = unwarp(img, UpSampFactor=1,rad=1032,cent_x=516,cent_y=516,width_to_height=3)
#
# #def unwarp(img, UpSampFactor, rad, cent_x, cent_y, width_to_height=3):
# # 保存并显示扭曲后的图像
# warped_image_path = 'output_data/unwarp_allsky_2021-09-28T1701Z.png'
# plt.imsave(warped_image_path, im_warp, cmap='gray')
# print(f"Warped image saved as {warped_image_path}")



# 获取当前代码文件所在的目录


# 指定输入图片名称
input_image_name = '/content/WechatIMG170.jpg'

# 构造输入图片路径：base_dir + 'data' + input_image_name
input_image_path = input_image_name
print(input_image_path)

# 检查输入图像是否存在
if not os.path.exists(input_image_path):
    print(f"Error: Image file '{input_image_path}' does not exist.")
else:
    # 读取灰度图像
    img = cv2.imread(input_image_path,cv2.IMREAD_COLOR)

    if img is None:
        print(f"Error: Unable to load image at {input_image_path}")
    else:
        # 调用扭曲函数
        im_warp = warp(img, UpSampFactor=1)

        # 确保值在 0 到 255 之间并转换为整型
        im_warp = np.clip(im_warp, 0, 255).astype(np.uint8)

        # 构造输出图片路径：base_dir + 'output_data' + 'unwarp_' + 原图文件名


        output_image_path = '/content/unwraped_image.jpg'
        # 保存并显示扭曲后的图像
        plt.imsave(output_image_path, im_warp, cmap='gray')
        print(f"Warped image saved as {output_image_path}")


# 可视化处理前后的图像
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(img, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title('Unwrapped Image')
plt.imshow(im_warp, cmap='gray')
plt.axis('off')

plt.imshow(im_warp, cmap='gray')
plt.show()
# 保存对比图像
comparison_image_path = os.path.join(output_dir, 'comparison_' + input_image_name)
plt.savefig(comparison_image_path)
print(f"Comparison image saved as {comparison_image_path}")

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import seaborn as sns

from scipy.stats import multivariate_normal

mean1 = np.array([10,2])
mean2 = np.array([0,0])
cov1 = np.vstack([[1,0],[0,1]])
cov2 = np.vstack([[1.7,2.],[2.,8.4]]) # Note, diagonals flipped from book to match figure shape.
n = 3000
first = np.round(np.random.multivariate_normal(mean1, cov1, int(n/4))*.4,3) # n/4 to adjust distribution to book figure for countour plot.
second = np.round(np.random.multivariate_normal(mean2, cov2, n)*.6,3)
data = np.vstack([first,second])
np.shape(data)
fig = plt.figure(figsize=(14, 12))
gs = GridSpec(2, 2, width_ratios=[4, 1], height_ratios=[1, 4])
ax1 = fig.add_subplot(gs[0])
ax3 = fig.add_subplot(gs[2])
ax3.axis('equal')
ax4 = fig.add_subplot(gs[3])
bins = 100
# Figure setup.

# Central scatter plot.
ax3.scatter(data[:,0],data[:,1], s = .5, alpha = .5)
sns.kdeplot(data[:,0], data[:,1],n_levels=10, cmap="viridis_r", ax = ax3, bw = 1)
ax3.scatter(np.mean(data[:,0]),np.mean(data[:,1]), marker = "o", color = "magenta")
ax3.scatter(max(set(first[:,0]), key=list(first[:,0]).count), max(set(first[:,1]), key=list(first[:,1]).count), marker = "*", c = "k")
ax3.scatter(max(set(second[:,0]), key=list(second[:,0]).count), max(set(second[:,1]), key=list(second[:,1]).count), marker = "*", c = "k")
# Central scatter plot.

# X distribution.
sns.distplot(data[:,0], ax = ax1, bins = bins)
ax1.scatter(np.median(data[:,0]),0, label = "median", marker = "s", c = "r")
ax1.scatter(np.mean(data[:,0]), 0, label = "mean", marker = "o", c = "magenta")
ax1.scatter(max(set(first[:,0]), key=list(first[:,0]).count),0, label = "modes", marker = "*", c = "k")
ax1.scatter(max(set(second[:,0]), key=list(second[:,0]).count),0, label="_nolegend_", marker = "*", c = "k")
ax1.legend()
# X distribution.

# Y distribution.
sns.distplot(data[:,1], ax = ax4, vertical = True, bins = bins)
ax4.scatter(0,max(set(first[:,1]), key=list(first[:,1]).count), marker = "*", c = "k")
ax4.scatter(0,max(set(second[:,1]), key=list(second[:,1]).count), marker = "*", c = "k")
ax4.scatter(0, np.mean(data[:,1]), marker = "o", c = "magenta")
ax4.scatter(0,np.median(data[:,1]), marker = "s", c = "r");
# Y distribution.